#!/usr/bin/env python

import argparse
import datetime
import logging
import os
import re
import subprocess
import sys
import tempfile
import toml

class Module:
    def __init__(self, name, src, hdr, meta):
        self.name = name
        self.src = src
        self.hdr = hdr
        self.meta = meta
        self.depends = []

class GitInfo:
    GIT = os.environ.get("GIT", "git")

    def __init__(self, root):
        self.root = root

        p = subprocess.run([GitInfo.GIT, "-C", root, "rev-parse", "HEAD"], capture_output=True, text=True, check=True)
        self.ref = p.stdout.splitlines()[0]
        logger.debug(f"git ref: {self.ref}")

        p = subprocess.run([GitInfo.GIT, "-C", root, "status", "--porcelain"], capture_output=True, text=True, check=True)
        self.dirty = len(p.stdout.splitlines()) > 0
        logger.debug(f"git dirty: {self.dirty}")

        p = subprocess.run([GitInfo.GIT, "-C", root, "remote"], capture_output=True, text=True, check=True)
        remote = p.stdout.splitlines()[0]

        p = subprocess.run([GitInfo.GIT, "-C", root, "remote", "get-url", remote], capture_output=True, text=True, check=True)
        upstream = p.stdout.splitlines()[0]
        logger.debug(f"git upstream (remote): {upstream}")

        if upstream.startswith("git@github.com:"):
            self.url = upstream.replace("git@github.com:", "https://github.com/")
        else:
            self.url = upstream
        logger.debug(f"git url: {self.url}")

    def make(target):
        p = subprocess.run([GitInfo.GIT, "-C", target, "rev-parse", "--show-toplevel"], capture_output=True, text=True)
        if p.returncode != 0:
            logger.warn(f"unable to figure out git context: {p.stderr}")
            return None
        root = p.stdout.splitlines()[0]
        logger.debug(f"git root: {root}")

        return GitInfo(root=root)

class Meta:
    def __init__(self, spec, args):
        self.version = spec["version"]

        self.name = spec.get("name")
        if self.name is None:
            self.name = os.path.basename(args.root)

        self.include_guard = spec.get("include_guard", f"{self.name.upper()}_HEADER")
        self.implementation_guard = spec.get("implementation_guard", f"{self.name.upper()}_IMPLEMENTATION")

        self.git = GitInfo.make(args.root)

def load_modules(spec, args):
    meta = Meta(spec, args)

    modules = {}
    for n, m in spec["module"].items():
        src = os.path.join(args.src, f"{n}.c")
        hdr = os.path.join(args.include, f"{n}.h")
        modules[n] = Module(name=n, src=src, hdr=hdr, meta=meta)

    for n, m in modules.items():
        depends = spec["module"][n].get("depends", [])
        if not isinstance(depends, list):
            depends = [ depends ]
        m.depends = [ modules[d] for d in depends ]

    return modules

def select_modules(modules, selection):
    ms = {}
    def go(m):
        if m.name not in ms:
            ms[m.name] = m
            for d in m.depends:
                go(d)

    for s in selection:
        go(modules[s])

    return list(ms.values())

def bundle_modules(modules, output):
    if len(modules) == 0:
        raise RuntimeError("no modules to bundle")

    meta = modules[0].meta

    with tempfile.TemporaryFile() as f:
        when = datetime.datetime.now().astimezone().isoformat(timespec="seconds")
        version = f"{meta.version}"
        if meta.git:
            if meta.git.dirty:
                version += f" ({meta.git.ref} dirty)"
            else:
                version += f" ({meta.git.ref})"

            version += f" ({meta.git.url})"
        f.write(f"// {meta.name} {version} ({when})\n".encode("UTF-8"))
        f.write(f"// modules: {' '.join([m.name for m in modules])}\n\n".encode("UTF-8"))

        f.write(f"#ifndef {meta.include_guard}\n".encode("UTF-8"))
        f.write(f"#define {meta.include_guard}\n".encode("UTF-8"))
        for m in modules:
            f.write(f"\n// {meta.name} {os.path.basename(m.hdr)}\n".encode("UTF-8"))
            with open(m.hdr, "r") as h:
                for l in h.readlines():
                    if l.startswith("#pragma once"):
                        continue
                    f.write(l.encode("UTF-8"))
        f.write(f"#endif // {meta.include_guard}\n\n".encode("UTF-8"))

        f.write(f"#ifdef {meta.implementation_guard}\n".encode("UTF-8"))
        r_include = re.compile(r'^#include\s+"[^"]+"')
        for m in modules:
            f.write(f"\n// {meta.name} {os.path.basename(m.src)}\n".encode("UTF-8"))
            with open(m.src, "r") as h:
                for l in h.readlines():
                    if r_include.match(l):
                        continue
                    f.write(l.encode("UTF-8"))
        f.write(f"#endif // {meta.implementation_guard}\n".encode("UTF-8"))

        f.seek(0)
        output.write(f.read())

def parse_args():
    parser = argparse.ArgumentParser(description="Single file bundler")

    parser.add_argument("--log", default=os.environ.get("LOG_LEVEL", "WARN"), help="set log level")
    parser.add_argument("--root", default=os.environ.get("ROOT", os.path.dirname(os.path.realpath(__file__))))

    parser.add_argument("--src", default=os.environ.get("SRC"))
    parser.add_argument("--include", default=os.environ.get("INCLUDE"))

    subparsers = parser.add_subparsers(dest="cmd")

    list_cmd = subparsers.add_parser("list")
    list_cmd.add_argument("selection", metavar="MODULE", nargs="*")

    bundle_cmd = subparsers.add_parser("bundle")
    bundle_cmd.add_argument("-o", "--output", default=os.environ.get("OUTPUT"))
    bundle_cmd.add_argument("selection", metavar="MODULE", nargs="*")

    args = parser.parse_args()

    if args.src is None:
        args.src = os.path.join(args.root, "src")

    if args.include is None:
        args.include = os.path.join(args.root, os.path.join("include", "r"))

    return args

logger = None
def setup_logger(level):
    l = logging.getLogger("bundle")
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(
        fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

if __name__ == "__main__":
    args = parse_args()
    logger = setup_logger(args.log.upper())
    logger.debug(f"args: {args}")

    with open(os.path.join(args.root, "libr.toml"), "r") as f:
        spec = toml.load(f)
        logger.debug(f"spec: {spec}")
        modules = load_modules(spec, args)

    if args.cmd == "list":
        if args.selection:
            for m in select_modules(modules, args.selection):
                print(m.name)
        else:
            for n in modules.keys():
                print(n)
    elif args.cmd == "bundle":
        selection = select_modules(modules, args.selection)
        if args.output:
            output = open(args.output, "wb")
        else:
            output = sys.stdout.buffer
        bundle_modules(selection, output=output)
